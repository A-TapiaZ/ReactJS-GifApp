{"version":3,"sources":["components/AddCategory.js","components/GifGridItem.js","helpers/getGifs.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setcategorie","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","categorie","type","value","onChange","target","GifGridItem","title","url","className","src","alt","getGifs","category","a","encodeURI","fetch","resp","json","data","gifs","map","id","images","downsized_medium","GifGrid","loading","state","setstate","useEffect","then","imgs","useFetchGifts","img","key","GifExpertApp","props","categories","ReactDOM","render","document","getElementById"],"mappings":"2MAIaA,EAAc,SAAC,GAAoB,IAAnBC,EAAkB,EAAlBA,aAAkB,EAETC,mBAAS,IAFA,mBAEtCC,EAFsC,KAE1BC,EAF0B,KA0B7C,OACE,0BAAMC,SAnBY,SAACC,GAEnBA,EAAEC,iBAMCJ,EAAWK,OAAOC,OAAO,IAG1BR,GAAc,SAACS,GAAD,OAAeP,GAAf,mBAA6BO,OAG3CN,EAAc,OAMd,2BACEO,KAAK,OACLC,MAAOT,EACPU,SA3BmB,SAACP,GACxBF,EAAcE,EAAEQ,OAAOF,YCQZG,EAdK,SAAC,GAAiB,IAAhBC,EAAe,EAAfA,MAAMC,EAAS,EAATA,IAE1B,OACE,yBAAKC,UAAU,0CACb,yBAAKC,IAAKF,EAAKG,IAAKJ,IACpB,2BAAIA,K,uBCNGK,EAAO,uCAAE,WAAMC,GAAN,uBAAAC,EAAA,6DACdN,EADc,iDACiCO,UAAUF,GAD3C,+DAGFG,MAAMR,GAHJ,cAGdS,EAHc,gBAIAA,EAAKC,OAJL,uBAIbC,EAJa,EAIbA,KAEDC,EAAMD,EAAKE,KAAI,YAAwB,IAAtBC,EAAqB,EAArBA,GAAGf,EAAkB,EAAlBA,MAAMgB,EAAY,EAAZA,OAC9B,MAAM,CACJD,GAAGA,EACHf,MAAMA,EACNC,IAAG,OAACe,QAAD,IAACA,OAAD,EAACA,EAAQC,iBAAiBhB,QAVb,kBAgBbY,GAhBa,4CAAF,sDC2BLK,EAxBC,SAAC,GAAgB,IAAfZ,EAAc,EAAdA,SAAc,ECFH,SAACA,GAAc,IAAD,EAEfpB,mBAAS,CACjC0B,KAAK,GACLO,SAAQ,IAJ+B,mBAElCC,EAFkC,KAE3BC,EAF2B,KAmBzC,OAXAC,qBAAU,WACRjB,EAAQC,GACLiB,MAAK,SAAAC,GACJH,EAAS,CACPT,KAAKY,EACLL,SAAQ,SAGb,CAACb,IAGGc,EDfsBK,CAAcnB,GAA/BU,EAFkB,EAEvBJ,KAAYO,EAFW,EAEXA,QAEnB,OAEE,oCACE,wBAAIjB,UAAW,qCAAsCI,GACrD,uBAAGJ,UAAU,oCAAoCiB,GAAW,WAC5D,yBAAKjB,UAAU,aAEXc,EAAOF,KAAK,SAACY,GAAD,OACV,kBAAC,EAAD,iBACIA,EADJ,CAEAC,IAAKD,EAAIX,YE6BNa,EA3CM,SAAAC,GAAS,MAGO3C,mBAAS,CAAC,cAHjB,mBAGrB4C,EAHqB,KAGT7C,EAHS,KAgB5B,OACE,oCACE,4CACA,kBAAC,EAAD,CACEA,aAAcA,IAEhB,6BAEA,4BAEI6C,EAAWhB,KAAI,SAAAR,GAAQ,OACrB,kBAAC,EAAD,CACAqB,IAAMrB,EACNA,SAAUA,U,YC3BtByB,IAASC,OACP,kBAAC,EAAD,MACAC,SAASC,eAAe,U","file":"static/js/main.a50cca89.chunk.js","sourcesContent":["import React, { useState } from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\n\r\nexport const AddCategory = ({setcategorie}) => {\r\n\r\n  const [inputValue, setInputValue] = useState('')\r\n  \r\n  const handleInputChange= (e) => {\r\n    setInputValue(e.target.value);\r\n  }\r\n  \r\n  const handleSubmit= (e) => {\r\n    // Previene que por ejemplo en un submit se recargue el formulario.\r\n    e.preventDefault();\r\n\r\n    // De esta forma no sirve porque no  estoy enviando categorie en los props, entonces no encuentra una referencia de que es categorie.\r\n    // setcategorie( [...categorie, 'DBZ'])\r\n\r\n    \r\n    if(inputValue.trim().length>2){\r\n      \r\n      // Tendria que ser de esta forma, ya que al momento de llamar la funcion esta se puede llamar con un callback que tiene el estado anterior.\r\n      setcategorie( (categorie)=> [inputValue,...categorie,])\r\n\r\n      // Con esto evitamos que ingrese el mismo valor aprentado solo enter\r\n      setInputValue('')\r\n    }\r\n  }\r\n  \r\n  return (\r\n    <form onSubmit={handleSubmit}>\r\n      <input\r\n        type='text'\r\n        value={inputValue}\r\n        onChange={handleInputChange}\r\n      />\r\n    </form>\r\n  )\r\n}\r\n\r\nAddCategory.propTypes={\r\n  setcategorie:PropTypes.func.isRequired\r\n}","import React from 'react'\r\n// import PropTypes from 'prop-types'\r\n\r\nconst GifGridItem = ({title,url}) => {\r\n\r\n  return (\r\n    <div className=\"card animate__animated animate__fadeIn\">\r\n      <img src={url} alt={title}></img>\r\n      <p>{title}</p>\r\n    </div>\r\n  )\r\n}\r\n\r\nGifGridItem.propTypes = {\r\n\r\n}\r\n\r\nexport default GifGridItem\r\n","\r\n\r\nexport const getGifs= async(category) => {\r\n  const url =`https://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&limit=10&api_key=xptBHOPBvzBYXDWTJ7XDDRcfuTX3bV29`;\r\n\r\n  const resp= await fetch(url);\r\n  const {data}= await resp.json();\r\n\r\n  const gifs= data.map(({id,title,images}) => {\r\n    return{\r\n      id:id,\r\n      title:title,\r\n      url:images?.downsized_medium.url\r\n    }\r\n  }\r\n  )\r\n\r\n  // Regresa una promesa OJO\r\n  return(gifs);\r\n\r\n}","import React from 'react'\r\nimport GifGridItem from './GifGridItem';\r\nimport { useFetchGifts } from '../hooks/useFetchGifs';\r\n\r\n\r\nconst GifGrid = ({category}) => {\r\n\r\n  const {data:images,loading}= useFetchGifts(category)\r\n\r\n  return (\r\n\r\n    <>\r\n      <h3 className= \"animate__animated animate__fadeIn\" >{category}</h3>\r\n      <p className=\"animate__animated animate__flash\">{loading && 'Loading'}</p>\r\n      <div className=\"card-grid\">\r\n        {\r\n          images.map( (img) => (\r\n            <GifGridItem \r\n            {...img} \r\n            key={img.id} \r\n            />\r\n          ))\r\n        }\r\n      </div>\r\n    </>\r\n  )\r\n}\r\n\r\n\r\nexport default GifGrid\r\n","import { useState, useEffect } from \"react\"\r\nimport { getGifs } from \"../helpers/getGifs\"\r\n\r\nexport const useFetchGifts = (category) => {\r\n  \r\n  const [state, setstate] = useState({\r\n    data:[],\r\n    loading:true,\r\n  })\r\n\r\n  // El useEffect es un 'hook' el cual solo se va a ejecutar dependiendo de las depencias (segundo argumento). En otras palabras es una suscripcion a algo, y cada vez que vea que ese algo cambio, se va a volver a ejecutar con el fin de actualizarce.\r\n  useEffect(() => {\r\n    getGifs(category)\r\n      .then(imgs => {\r\n        setstate({\r\n          data:imgs,\r\n          loading:false,\r\n        });\r\n      })\r\n  }, [category])\r\n\r\n\r\n  return state;\r\n}\r\n","import React, { useState } from 'react'\r\nimport { AddCategory } from './components/AddCategory'\r\nimport GifGrid from './components/GifGrid'\r\n// import PropTypes from 'prop-types'\r\n\r\nconst GifExpertApp = props => {\r\n  // const categories=['one punch', 'Samurai X', 'Naruto']\r\n\r\n  const [categories, setcategorie] = useState(['One punch'])\r\n\r\n/*\r\n  const addCategorie= () => {\r\n\r\n    // NO se porquÃ©, pero cuando sale de la funcion no sale como array sino que sale como number (4), por lo que, cuando vuelve a renderizar y llega al punto  de la funcion map, este arroja un error diciendo que .map no es una funcion y tiene logica, que voy a recorrer si solo tengo un numero?. \r\n    // setcategorie(categories => categorie.push('DBZ'))\r\n\r\n    // Esta es la solucion correcta\r\n    setcategorie( [...categorie, 'DBZ'])\r\n\r\n  }\r\n*/\r\n  return (\r\n    <>\r\n      <h2>GifExpertApp</h2>\r\n      <AddCategory\r\n        setcategorie={setcategorie}\r\n        />\r\n      <hr />\r\n\r\n      <ol>\r\n        {\r\n          categories.map(category => \r\n            <GifGrid \r\n            key= {category}\r\n            category={category}/>\r\n          )\r\n        }\r\n      </ol>\r\n\r\n\r\n    </>\r\n  )\r\n}\r\n\r\nGifExpertApp.propTypes = {\r\n\r\n}\r\n\r\nexport default GifExpertApp\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport GifExpertApp from './GifExpertApp';\nimport './index.css';\nimport 'animate.css'\n\n\nReactDOM.render(\n  <GifExpertApp/>,\n  document.getElementById('root')\n);\n "],"sourceRoot":""}